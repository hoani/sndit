package generate

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"
	"text/template"

	"github.com/stretchr/testify/require"
)

func TestGenerate_SfxDirectory(t *testing.T) {
	testCases := []struct {
		name    string
		dirname string
	}{
		{
			name:    "sfx only",
			dirname: "sfx",
		},
		{
			name:    "sfx prefix",
			dirname: "sfx_play",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {

			dir := t.TempDir()

			sfxDir := filepath.Join(dir, tc.dirname)
			require.NoError(t, os.Mkdir(sfxDir, 0o755))
			writeFile(t, sfxDir, "die.wav")
			writeFile(t, sfxDir, "move.wav")

			require.NoError(t, Generate(dir, "github.com/hoani/mygame"))

			got := readGenerated(t, sfxDir)

			want := fmt.Sprintf(`// Code generated by sndit; DO NOT EDIT.
package %s

import (
	_ "embed"
	"fmt"

	"github.com/hoani/sndit"
)

//go:embed "die.wav"
var die_wav []byte

//go:embed "move.wav"
var move_wav []byte

type Sound int

const (
	Die Sound = iota
	Move
)

var engine *sndit.SfxEngine[Sound]

func Init(ctx sndit.Context) error {
	engine = sndit.NewSfx[Sound](ctx)
	if err := engine.Register(Die, die_wav); err != nil {
		return fmt.Errorf("registering Die: %%w", err)
	}
	if err := engine.Register(Move, move_wav); err != nil {
		return fmt.Errorf("registering Move: %%w", err)
	}
	return nil
}

func Play(id Sound) {
	engine.Play(id)
}
`, tc.dirname)

			require.Equal(t, want, got)
		})
	}
}

func TestGenerate_MusDirectory(t *testing.T) {
	dir := t.TempDir()

	musDir := filepath.Join(dir, "mus_theme")
	require.NoError(t, os.Mkdir(musDir, 0o755))
	writeFile(t, musDir, "title.wav")
	writeFile(t, musDir, "gameplay.wav")

	require.NoError(t, Generate(dir, "github.com/hoani/mygame"))

	got := readGenerated(t, musDir)

	want := `// Code generated by sndit; DO NOT EDIT.
package mus_theme

import (
	_ "embed"
	"fmt"

	"github.com/hoani/sndit"
)

//go:embed "gameplay.wav"
var gameplay_wav []byte

//go:embed "title.wav"
var title_wav []byte

type Sound int

const (
	Gameplay Sound = iota
	Title
)

var engine *sndit.MusicEngine[Sound]

func Init(ctx sndit.Context) error {
	engine = sndit.NewMusic[Sound](ctx)
	if err := engine.Register(Gameplay, gameplay_wav); err != nil {
		return fmt.Errorf("registering Gameplay: %w", err)
	}
	if err := engine.Register(Title, title_wav); err != nil {
		return fmt.Errorf("registering Title: %w", err)
	}
	return nil
}

func Play(id Sound) {
	engine.Play(id)
}

func Stop() {
	engine.Stop()
}
`

	require.Equal(t, want, got)
}

func TestGenerate_SkipsEmptyDirectories(t *testing.T) {
	dir := t.TempDir()

	sfxDir := filepath.Join(dir, "sfx_empty")
	require.NoError(t, os.Mkdir(sfxDir, 0o755))

	require.NoError(t, Generate(dir, "github.com/hoani/mygame"))

	genPath := filepath.Join(sfxDir, "sounds_gen.go")
	_, err := os.Stat(genPath)
	require.True(t, os.IsNotExist(err), "expected no generated file for empty directory")
}

func TestGenerate_SkipsNonMatchingDirectories(t *testing.T) {
	dir := t.TempDir()

	otherDir := filepath.Join(dir, "other")
	require.NoError(t, os.Mkdir(otherDir, 0o755))
	writeFile(t, otherDir, "sound.wav")

	require.NoError(t, Generate(dir, "github.com/hoani/mygame"))

	genPath := filepath.Join(otherDir, "sounds_gen.go")
	_, err := os.Stat(genPath)
	require.True(t, os.IsNotExist(err), "expected no generated file for non-matching directory")
}

func TestGenerate_MultipleDirectories(t *testing.T) {
	dir := t.TempDir()

	sfxDir := filepath.Join(dir, "sfx_play")
	musDir := filepath.Join(dir, "mus_bg")
	require.NoError(t, os.Mkdir(sfxDir, 0o755))
	require.NoError(t, os.Mkdir(musDir, 0o755))
	writeFile(t, sfxDir, "click.wav")
	writeFile(t, musDir, "loop.wav")

	require.NoError(t, Generate(dir, "github.com/hoani/mygame"))

	require.FileExists(t, filepath.Join(sfxDir, "sounds_gen.go"))
	require.FileExists(t, filepath.Join(musDir, "sounds_gen.go"))
}

func TestGenerate_SkipsNonWavFiles(t *testing.T) {
	dir := t.TempDir()

	sfxDir := filepath.Join(dir, "sfx_play")
	require.NoError(t, os.Mkdir(sfxDir, 0o755))
	writeFile(t, sfxDir, "click.wav")
	writeFile(t, sfxDir, "readme.txt")

	require.NoError(t, Generate(dir, "github.com/hoani/mygame"))

	got := readGenerated(t, sfxDir)

	// Should only include click.wav, not readme.txt.
	want := `// Code generated by sndit; DO NOT EDIT.
package sfx_play

import (
	_ "embed"
	"fmt"

	"github.com/hoani/sndit"
)

//go:embed "click.wav"
var click_wav []byte

type Sound int

const (
	Click Sound = iota
)

var engine *sndit.SfxEngine[Sound]

func Init(ctx sndit.Context) error {
	engine = sndit.NewSfx[Sound](ctx)
	if err := engine.Register(Click, click_wav); err != nil {
		return fmt.Errorf("registering Click: %w", err)
	}
	return nil
}

func Play(id Sound) {
	engine.Play(id)
}
`

	require.Equal(t, want, got)
}

func TestGenerate_InvalidRootDir(t *testing.T) {
	err := Generate("/nonexistent/path", "github.com/hoani/mygame")
	require.Error(t, err)
	require.Contains(t, err.Error(), "reading root dir")
}

func TestGenerate_SkipsFilesInRoot(t *testing.T) {
	dir := t.TempDir()

	// A file (not directory) in root should be skipped.
	writeFile(t, dir, "stray.wav")

	require.NoError(t, Generate(dir, "github.com/hoani/mygame"))
}

func TestGenerate_SkipsSubdirectoriesInSoundDir(t *testing.T) {
	dir := t.TempDir()

	sfxDir := filepath.Join(dir, "sfx_play")
	require.NoError(t, os.Mkdir(sfxDir, 0o755))
	writeFile(t, sfxDir, "click.wav")
	// Subdirectory inside sfx_play should be ignored by collectWavFiles.
	require.NoError(t, os.Mkdir(filepath.Join(sfxDir, "nested"), 0o755))

	require.NoError(t, Generate(dir, "github.com/hoani/mygame"))
	got := readGenerated(t, sfxDir)
	require.Contains(t, got, "Click Sound = iota")
	require.NotContains(t, got, "nested")
}

func TestGenerate_UnreadableSoundDir(t *testing.T) {
	dir := t.TempDir()

	sfxDir := filepath.Join(dir, "sfx_broken")
	require.NoError(t, os.Mkdir(sfxDir, 0o755))
	writeFile(t, sfxDir, "click.wav")
	// Make the directory unreadable after creating files.
	require.NoError(t, os.Chmod(sfxDir, 0o000))
	t.Cleanup(func() { _ = os.Chmod(sfxDir, 0o755) })

	err := Generate(dir, "github.com/hoani/mygame")
	require.Error(t, err)
	require.Contains(t, err.Error(), "scanning")
}

func TestGenerate_ReadOnlyOutputDir(t *testing.T) {
	dir := t.TempDir()

	sfxDir := filepath.Join(dir, "sfx_play")
	require.NoError(t, os.Mkdir(sfxDir, 0o555))
	t.Cleanup(func() { _ = os.Chmod(sfxDir, 0o755) })

	writeFile(t, dir, "sfx_play_placeholder") // ensure dir entry exists
	// We need a .wav file to trigger generation; write it before chmod.
	require.NoError(t, os.Chmod(sfxDir, 0o755))
	writeFile(t, sfxDir, "click.wav")
	require.NoError(t, os.Chmod(sfxDir, 0o555))

	err := Generate(dir, "github.com/hoani/mygame")
	require.Error(t, err)
	require.Contains(t, err.Error(), "creating")
}

func TestGenerate_TemplateExecuteError(t *testing.T) {
	dir := t.TempDir()

	sfxDir := filepath.Join(dir, "sfx_play")
	require.NoError(t, os.Mkdir(sfxDir, 0o755))
	writeFile(t, sfxDir, "click.wav")

	// Swap the sfx template with one that will fail during execution.
	orig := sfxTemplate
	sfxTemplate = template.Must(template.New("bad").Option("missingkey=error").Parse("{{.NoSuchField}}"))
	t.Cleanup(func() { sfxTemplate = orig })

	err := Generate(dir, "github.com/hoani/mygame")
	require.Error(t, err)
	require.Contains(t, err.Error(), "executing template")
}

func writeFile(t *testing.T, dir, name string) {
	t.Helper()
	require.NoError(t, os.WriteFile(filepath.Join(dir, name), []byte("fake"), 0o644))
}

func readGenerated(t *testing.T, dir string) string {
	t.Helper()
	data, err := os.ReadFile(filepath.Join(dir, "sounds_gen.go"))
	require.NoError(t, err)
	return string(data)
}
