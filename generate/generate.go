package generate

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"unicode"
)

type dirKind int

const (
	kindSfx dirKind = iota
	kindMusic
)

type soundEntry struct {
	ConstName string
	VarName   string
	FileName  string
}

type templateData struct {
	Package string
	Sounds  []soundEntry
	Kind    dirKind
}

var sfxTemplate = template.Must(template.New("sfx").Parse(`// Code generated by sndit; DO NOT EDIT.
package {{.Package}}

import (
	_ "embed"
	"github.com/hoani/sndit"
)

{{range .Sounds}}//go:embed "{{.FileName}}"
var {{.VarName}} []byte

{{end}}type Sound int

const (
{{- range $i, $s := .Sounds}}
{{- if eq $i 0}}
	{{$s.ConstName}} Sound = iota
{{- else}}
	{{$s.ConstName}}
{{- end}}
{{- end}}
)

var engine *sndit.SfxEngine[Sound]

func Init(ctx sndit.Context) {
	engine = sndit.NewSfx[Sound](ctx)
{{- range .Sounds}}
	engine.Register({{.ConstName}}, {{.VarName}})
{{- end}}
}

func Play(id Sound) {
	engine.Play(id)
}
`))

var musicTemplate = template.Must(template.New("music").Parse(`// Code generated by sndit; DO NOT EDIT.
package {{.Package}}

import (
	_ "embed"
	"github.com/hoani/sndit"
)

{{range .Sounds}}//go:embed "{{.FileName}}"
var {{.VarName}} []byte

{{end}}type Sound int

const (
{{- range $i, $s := .Sounds}}
{{- if eq $i 0}}
	{{$s.ConstName}} Sound = iota
{{- else}}
	{{$s.ConstName}}
{{- end}}
{{- end}}
)

var engine *sndit.MusicEngine[Sound]

func Init(ctx sndit.Context) {
	engine = sndit.NewMusic[Sound](ctx)
{{- range .Sounds}}
	engine.Register({{.ConstName}}, {{.VarName}})
{{- end}}
}

func Play(id Sound) {
	engine.Play(id)
}

func Stop() {
	engine.Stop()
}
`))

// Generate scans rootDir for sfx_* and mus_* subdirectories containing .wav
// files, and generates a sounds_gen.go file in each.
func Generate(rootDir string, modulePath string) error {
	entries, err := os.ReadDir(rootDir)
	if err != nil {
		return fmt.Errorf("reading root dir: %w", err)
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		name := entry.Name()
		var kind dirKind
		switch {
		case strings.HasPrefix(name, "sfx_"):
			kind = kindSfx
		case strings.HasPrefix(name, "mus_"):
			kind = kindMusic
		default:
			continue
		}

		dirPath := filepath.Join(rootDir, name)
		sounds, err := collectWavFiles(dirPath)
		if err != nil {
			return fmt.Errorf("scanning %s: %w", name, err)
		}

		if len(sounds) == 0 {
			continue
		}

		data := templateData{
			Package: name,
			Sounds:  sounds,
			Kind:    kind,
		}

		outPath := filepath.Join(dirPath, "sounds_gen.go")
		f, err := os.Create(outPath)
		if err != nil {
			return fmt.Errorf("creating %s: %w", outPath, err)
		}

		var tmpl *template.Template
		if kind == kindSfx {
			tmpl = sfxTemplate
		} else {
			tmpl = musicTemplate
		}

		if err := tmpl.Execute(f, data); err != nil {
			f.Close()
			return fmt.Errorf("executing template for %s: %w", name, err)
		}
		f.Close()
	}

	return nil
}

func collectWavFiles(dir string) ([]soundEntry, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	var sounds []soundEntry
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		if !strings.HasSuffix(strings.ToLower(name), ".wav") {
			continue
		}
		base := strings.TrimSuffix(name, filepath.Ext(name))
		sounds = append(sounds, soundEntry{
			ConstName: pascalCase(base),
			VarName:   base + "_wav",
			FileName:  name,
		})
	}

	sort.Slice(sounds, func(i, j int) bool {
		return sounds[i].ConstName < sounds[j].ConstName
	})

	return sounds, nil
}

func pascalCase(s string) string {
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}
